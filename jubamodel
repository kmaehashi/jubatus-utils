#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
jubamodel - Dump/Transform Jubatus Model Files
Copyright Â© 2013-2014 Kenichi Maehashi. All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License version 2.1 as published by the Free Software Foundation.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
'''

import sys
from struct import pack, unpack, calcsize
from binascii import crc32
from cStringIO import StringIO
import base64
import optparse

import msgpack
import json

class JubaModel(object):
  def start(self, in_file, out_file, out_config, in_format, out_format, no_validate, fix_header):
    # input
    try:
      with open(in_file) as f:
        if in_format == 'auto':
          in_format = JubaModelFile.probe_format(f)
        if in_format == 'binary':
          model = JubaModelFile.load_binary(f, not no_validate)
        elif in_format == 'json':
          model = JubaModelFile.load_json(f)
        else:
          raise ValueError(in_format)
    except InvalidModelFormatError as e:
      print("Error: invalid model format: {0}".format(e))
      return
    except Exception as e:
      print("Error: failed to read model ({0}): {1}".format(e.__class__.__name__, e))
      return

    if fix_header:
      model.update_header()

    # output
    out = sys.stdout
    if out_file:
      out = open(out_file, 'wb')
    try:
      if out_format == 'binary':
        model.dump_binary(out)
      elif out_format == 'json':
        model.dump_json(out)
      elif out_format == 'text':
        model.dump_text(out)
      else:
        raise ValueError(out_format)
    except Exception as e:
      print("Error: failed to write model ({0}): {1}".format(e.__class__.__name__, e))
      return
    finally:
      out.close()

    # out_config
    if out_config:
      with open(out_config, 'wb') as f:
        f.write(model.system_data.config)

class JubaModelFile(object):
  MAGIC = 'jubatus\0'

  def __init__(self):
    self.header =      JubaModelFile.Header()
    self.system_data = JubaModelFile.SystemDataContainer()
    self.user_data =   JubaModelFile.UserDataContainer()
    self.user_data_raw = ''

  def update_header(self):
    self.header.magic_number = self.MAGIC

    buf_header = StringIO()
    buf_system = StringIO()

    try:
      self.system_data.dump(buf_system)
      self.header.system_data_size = len(buf_system.getvalue())

      self.header.user_data_size = len(self.user_data_raw)

      checksum = 0
      self.header.dump(buf_header, False)

      checksum = crc32(buf_header.getvalue(), checksum)
      checksum = crc32(buf_system.getvalue(), checksum)
      checksum = crc32(self.user_data_raw, checksum)
      self.header.crc32 = unpack('I', pack('i', checksum))[0]
    finally:
      buf_header.close()
      buf_system.close()

  @classmethod
  def probe_format(cls, f):
    m = f.read(1)
    f.seek(-1, 1)
    if m == cls.MAGIC[0]:
      return 'binary'
    elif m == '{':
      return 'json'
    raise InvalidModelFormatError('failed to auto-detect format')

  @classmethod
  def load_binary(cls, f, validate=True):
    m = JubaModelFile()

    if validate:
      checksum = 0

      # header
      h = JubaModelFile.Header.load(f)
      if not h.magic_number == cls.MAGIC:
        raise InvalidModelFormatError('invalid magic value: {0}'.format(h.magic_number))
      m.header = h
      checksum = crc32(h.dump(StringIO(), False).getvalue(), checksum)

      # system_data
      buf = f.read(h.system_data_size)
      if h.system_data_size != len(buf):
        raise InvalidModelFormatError(
            'EOF detected while reading system_data: ' +
            'expected {0} bytes, got {1} bytes'.format(h.system_data_size, len(buf)))
      m.system_data = JubaModelFile.SystemDataContainer.load(StringIO(buf))
      checksum = crc32(buf, checksum)

      # user_data
      buf = f.read(h.user_data_size)
      if h.user_data_size != len(buf):
        raise InvalidModelFormatError(
            'EOF detected while reading user_data: ' +
            'expected {0} bytes, got {1} bytes'.format(h.user_data_size, len(buf)))
      m.user_data_raw = buf
      m.user_data = JubaModelFile.UserDataContainer.load(StringIO(buf))
      checksum = crc32(buf, checksum)

      # check CRC
      if unpack('I', pack('i', checksum))[0] != h.crc32:
        raise InvalidModelFormatError(
            'CRC32 mismatch: expected {0}, got {1}'.format(h.crc32, checksum))

      # must be EOF here
      if len(f.read(1)) != 0:
        raise InvalidModelFormatError('trailing garbage detected')
    else:
      m.header      = JubaModelFile.Header.load(f)
      m.system_data = JubaModelFile.SystemDataContainer.load(StringIO(f.read(m.header.system_data_size)))
      m.user_data_raw = f.read(m.header.user_data_size)
      m.user_data   = JubaModelFile.UserDataContainer.load(StringIO(m.user_data_raw))
    return m

  def dump_binary(self, f):
    self.header.dump(f)
    self.system_data.dump(f)
    f.write(self.user_data_raw)

  @classmethod
  def load_json(cls, f):
    model = cls()
    record = json.load(f)
    for entity in ['header', 'system_data']:
      getattr(model, entity).set_record(record[entity])

    if 'user_data_raw' in record:
      if 'user_data' in record:
        print >> sys.stderr('Warning: ignoreing user_data section as user_data_raw is available')
      model.user_data_raw = base64.b64decode(record['user_data_raw'])
      model.user_data = JubaModelFile.UserDataContainer.load(StringIO(model.user_data_raw))
    elif 'user_data' in record:
      print >> sys.stderr('Warning: converting user_data from JSON format may generate corrupt model')
      model.user_data.set_record(record['user_data'])
      buf = StringIO()
      model.user_data.dump(buf)
      model.user_data_raw = buf.getvalue()
    else:
      return InvalidModelFormatError('user_data or user_data_raw section does not exist')

    return model

  def dump_json(self, f, raw_user_data=True):
    record = {}
    for entity in ['header', 'system_data']:
      record[entity] = dict(getattr(self, entity).get_record())
    if raw_user_data:
      record['user_data_raw'] = base64.b64encode(self.user_data_raw)
    else:
      record['user_data'] = dict(self.user_data.get_record())
    json.dump(record, f, indent=2)

  def dump_text(self, f):
    buf = []
    for (heading, obj) in [ ('Header',      self.header),
                            ('System Data', self.system_data),
                            ('User Data',   self.user_data) ]:
      buf.append("------------------------------------------")
      buf.append(heading)
      buf.append("------------------------------------------")

      for (k, v) in obj.get_record():
        buf.append('{0:32}{1}'.format(k, v))
      buf.append('')
    f.write('\n'.join(buf))

  class Header(object):
    FIELDS = [
      ('magic_number'         , '8s'),
      ('format_version'       , '>Q'),
      ('jubatus_version_major', '>I'),
      ('jubatus_version_minor', '>I'),
      ('jubatus_version_maint', '>I'),
      ('crc32'                , '>I'),
      ('system_data_size'     , '>Q'),
      ('user_data_size'       , '>Q'),
    ]

    @classmethod
    def load(cls, f):
      h = cls()
      for (key, fmt) in cls.FIELDS:
        size = calcsize(fmt)
        value = f.read(size)
        if len(value) != size:
          raise InvalidModelFormatError('failed to read {0} in header'.format(key))
        try:
          value_unpack = unpack(fmt, value)[0]
        except ValueError:
          raise InvalidModelFormatError('failed to parse {0} value {1} as {2}'.format(key, str(value), fmt))
        setattr(h, key, value_unpack)
      return h

    def dump(self, f, checksum=True):
      for (key, fmt) in self.FIELDS:
        if key != 'crc32' or checksum:
          f.write(pack(fmt, getattr(self, key)))
      return f

    def get_record(self):
      record = []
      for (key, fmt) in self.FIELDS:
        record.append((key, getattr(self, key)))
      return record

    def set_record(self, record):
      for (key, fmt) in self.FIELDS:
        value = record[key]
        if isinstance(value, unicode):
          value = str(value)
        setattr(self, key, value)

  class DataContainer(object):
    @classmethod
    def load(cls, f):
      return cls._load_array(msgpack.load(f))

    def dump(self, f):
      msgpack.dump(map(lambda x: x[1], self.get_record()), f)

    @classmethod
    def _load_array(cls, arr):
      dc = cls()
      dc.version = arr.pop(0)
      fields = cls.get_fields(dc.version)

      count_delta = len(fields) - len(arr)
      # TODO maybe some warnings required?
      if 0 < count_delta:
        # Less fields than expected.
        pass
      elif count_delta < 0:
        # More fields than expected.
        for i in xrange(count_delta):
          fields.append('UNKNOWN_FIELD_{0}'.format(i))
      for idx in xrange(len(arr)):
        setattr(dc, fields[idx], arr[idx])
      return dc

    @classmethod
    def get_fields(cls, version):
      raise NotImplementedError

    def get_record(self):
      record = [('version', self.version)]
      for f in self.get_fields(self.version):
        record.append((f, getattr(self, f)))
      return record

    def set_record(self, record):
      setattr(self, 'version', record['version'])
      for f in self.get_fields(self.version):
        setattr(self, f, record[f])

  class SystemDataContainer(DataContainer):
    FIELDS = ['timestamp', 'type', 'id', 'config']

    @classmethod
    def get_fields(cls, version):
      if version != 1:
        raise InvalidModelFormatError('unsupported system_data_container version')
      return cls.FIELDS

  class UserDataContainer(DataContainer):
    FIELDS = ['user_data']

    @classmethod
    def get_fields(cls, version):
      if version != 1:
        raise InvalidModelFormatError('unsupported user_data_container version')
      return cls.FIELDS

class InvalidModelFormatError(Exception):
  pass

if __name__ == '__main__':
  USAGE = '''
  jubamodel [--in-format IN_FORMAT] [--out-format OUT_FORMAT]
            [--no-validate] [--fix-header] [--output OUTPUT]  input_file
  jubamodel --help'''

  EPILOG = '  input_file            model file in format specified by --input'


  parser = optparse.OptionParser(add_help_option=False, usage=USAGE, epilog=EPILOG)

  # arguments
  parser.add_option('-i', '--in-format',       choices=('auto','binary','json'), default='auto',
                    help='model input format (default: %default)')
  parser.add_option('-o', '--out-format',      choices=('text','binary','json'), default='text',
                    help='model output format (default: %default)')
  parser.add_option('-O', '--output',          type='str',                       default=None,
                    help='specify output file instead of stdout')
  parser.add_option('-C', '--output-config',   type='str',                       default=None,
                    help='specify output file to config extracted from model')
  parser.add_option('-f', '--no-validate',     action='store_true',              default=False,
                    help='disable validation of binary model files')
  parser.add_option('-F', '--fix-header',      action='store_true',              default=False,
                    help='fix corrupt header if possible')
  parser.add_option('-h', '--help',            action='store_true',              default=False,
                    help='disable validation of model files')

  (args, files) = parser.parse_args()

  if args.help:
    parser.print_help()
    print ""
    print "Supported Model Formats:"
    print "  IN_FORMAT:  auto | binary | json"
    print "  OUT_FORMAT: text | binary | json"
    sys.exit(1)

  if len(files) == 0:
    parser.error('no model file specified')
  if len(files) != 1:
    parser.error('cannot specify multiple model files at once')

  jubamodel = JubaModel()
  jubamodel.start(files[0], args.output, args.output_config, args.in_format, args.out_format, args.no_validate, args.fix_header)
